next step
- norm v*
-- nzido transp... x
-- ngado dak l cube   v*
-- direct light v
-- negative objects it7at lih l condition v*
-- mhm norminet hhh x


bla matb9a define PI rah kaina fl bib dial math.h smita M_PI

# include "/Users/yataji/.brew/Cellar/sdl2/2.0.14/include/SDL2/SDL.h"
# include "/Users/yataji/.brew/Cellar/sdl2_image/2.0.5/include/SDL2/SDL_image.h"







// void	*draw(void *param)
// {
// 	t_rt		*rt;
// 	t_obj		*close;
// 	t_var		v;

// 	v.y = -1;
// 	v.near = -1.0;
// 	rt = (t_rt *)param;
// 	if (rt->menu == 0)
// 		menu(rt);
// 	if (rt->menu == 1)
// 	{
// 		while (++v.y < MAXWIDTH / 2)
// 		{
// 			v.x = -1;
// 			while (++v.x < MAXHEIGHT / 2)
// 			{
// 				rt->ray = initray(rt->tmpc, v.y, v.x);
// 				rt->tmpo = rt->obj;
// 				close = NULL;
// 				v.near = -1;
// 				drawcolor(v, close, *rt, rt->tmpo);
// 			}
// 		}
// 	}
// 	rt->filter_type = 0;
// 	filtres(rt);
// 	loop(rt);
// 	return (0);
// }

// void	*draw2(void *param)
// {
// 	t_rt		*rt;
// 	t_obj		*close;
// 	t_var		v;

// 	v.y = -1;
// 	v.near = -1.0;
// 	rt = (t_rt *)param;
// 	if (rt->menu == 0)
// 		menu(rt);
// 	if (rt->menu == 1)
// 	{
// 		while (++v.y < MAXWIDTH / 2)
// 		{
// 			v.x = MAXHEIGHT / 2 - 1;
// 			while (++v.x < MAXHEIGHT)
// 			{
// 				rt->ray = initray(rt->tmpc, v.y, v.x);
// 				rt->tmpo = rt->obj;
// 				close = NULL;
// 				v.near = -1;
// 				drawcolor(v, close, *rt, rt->tmpo);
// 			}
// 		}
// 	}
// 	rt->filter_type = 0;
// 	filtres(rt);
// 	loop(rt);
// 	return (0);
// }

// void	*draw3(void *param)
// {
// 	t_rt		*rt;
// 	t_obj		*close;
// 	t_var		v;

// 	v.y = MAXWIDTH / 2 - 1;
// 	v.near = -1.0;
// 	rt = (t_rt *)param;
// 	if (rt->menu == 0)
// 		menu(rt);
// 	if (rt->menu == 1)
// 	{
// 		while (++v.y < MAXWIDTH)
// 		{
// 			v.x = -1;
// 			while (++v.x < MAXHEIGHT / 2)
// 			{
// 				rt->ray = initray(rt->tmpc, v.y, v.x);
// 				rt->tmpo = rt->obj;
// 				close = NULL;
// 				v.near = -1;
// 				drawcolor(v, close, *rt, rt->tmpo);
// 			}
// 		}
// 	}
// 	rt->filter_type = 0;
// 	filtres(rt);
// 	loop(rt);
// 	return (0);
// }

// void	*draw4(void *param)
// {
// 	t_rt		*rt;
// 	t_obj		*close;
// 	t_var		v;

// 	v.y = MAXWIDTH / 2 - 1;
// 	v.near = -1.0;
// 	rt = (t_rt *)param;
// 	if (rt->menu == 0)
// 		menu(rt);
// 	if (rt->menu == 1)
// 	{
// 		while (++v.y < MAXWIDTH)
// 		{
// 			v.x = MAXHEIGHT / 2 - 1;
// 			while (++v.x < MAXHEIGHT)
// 			{
// 				rt->ray = initray(rt->tmpc, v.y, v.x);
// 				rt->tmpo = rt->obj;
// 				close = NULL;
// 				v.near = -1;
// 				drawcolor(v, close, *rt, rt->tmpo);
// 			}
// 		}
// 	}
// 	rt->filter_type = 0;
// 	filtres(rt);
// 	loop(rt);
// 	return (0);
// }

// void			multi_thread(t_rt *rt)
// {
// 	pthread_t	thread[4];

// 	pthread_create(&thread[0], NULL, &draw, rt);
// 	pthread_create(&thread[1], NULL, &draw2, rt);
// 	pthread_create(&thread[2], NULL, &draw3, rt);
// 	pthread_create(&thread[3], NULL, &draw4, rt);
// 	pthread_join(thread[0], NULL);
// 	pthread_join(thread[1], NULL);
// 	pthread_join(thread[2], NULL);
// 	pthread_join(thread[3], NULL);
// 	// mlx_put_image_to_window(mlx->ptr, mlx->win_ptr, mlx->img_ptr, 0, 0);
// }
